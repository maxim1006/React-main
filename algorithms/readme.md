### O
On the order of - the worst case scenario of algorithm. В процессе его вычислений достаточно много допущений, к примеру n^2 + 2n + 1 === O(n^2), или n - 1 === O(n) // где n - количество операций за который алгоритм приходит к финальному результату причем указывается всегда наихудшая ситуация

O(n^2) - bubble sort, selection sort
O(n log n) - merge sort
O(n) - linear search
O(log n) - binary search (на отсортированном массиве)
O(1)

### Ω (omega)
Best case scenario (omega of 1 - linear search)

Ω(n^2) - bubble sort (без условия что если swap = false остановись), selection sort
Ω(n log n) - merge sort
Ω(n) - bubble sort (c условием что если swap = false, те прошли один раз по массиву и ничего не поменяли, это индикатор чтобы остановить сортировку)
Ω(log n) 
Ω(1) - linear search, binary search



## SEARCH

### linear search O(n)
O(n) (On the order of n - efficiency of the algorithm )

Причем на бесконечном пространстве O(n) === O(n/2) (когда 2 числа за 1 раз например ищем) === O(n)

В лучшем случае мы найдем за 1 операцию в худшем за n

### binary search O(log n)
Работает быстрее чем линейный поиск но подразумевается что массив **отсортирован** по порядку (хорошая аналогия такого поиска орфографический словарь, если ищу букву то открываю посередине и тд)
делением попалам
сложность поиска по отсортированному массиву быстрее чем за линейное время:
O(log n)



## SORT

### selection sort (сортировка выбором) - O(n^2)
Есть массив неупорядоченных элементов, В двойном цикле сперва берем первый айтем, затем во втором цикле сравниваем с остальными и понимаем минимальный ли он, меняем местами с 1ым элементом, затем снова пробегаемся по массиву и меняем минимальное значение уже со вторым элементом и тд

В массиве 26 элементов и проходим за 325 итерация

получается что O(1/2*n^2) отбрасываю 1/2 получаю O(n^2)

### bubble sort - O(n^2)
В двойном цикле пробегаемся по массиву и сравниваем соседние элементы, если следующий элемент меньше чем предыдущий то меняем местами, получается своего рода всплытие
сортировка пузырьком 

### Quick sort (Hoare sort) - O(log 2n * n)
Принцип разделяй и власвуй. Рекурсивной функцией делим массив на подмассивы и каждый раз рекурсивно выбираем опорный элемент, чаще всего центральный, пробегаемся по массиву и все элементы который больше добавляем в 1 массив а те которые меньше в другой массив, для каждого из полученных массивов выполняю туже операцию и так делаю до тех пор пока длинна массива не равна 1, что и будет базовым условием для выхода из рекурсии. Затем полученные массивы склеиваются в 1 большой.

### recursion
это функция которая вызывает сама себя, должна иметь условие при котором вызов функции прекращается иначе будет бесконечный вызов

### Stack (push/pop)
LIFO
Элементы всегда добавляются в конец структуры и извлекаются также из конца (как пример стопка книг или тарелок)

### Queue (push, shift)
FIFO
В очереди элементы всегда вставляются в конец структуры, а извлекаются из ее начала (как очередь на кассу) 
FIFO - first in first out - первый вошел первый вышел
