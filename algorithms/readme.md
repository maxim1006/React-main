### O
On the order of - the worst case scenario of algorithm. В процессе его вычислений достаточно много допущений, к примеру n^2 + 2n + 1 === O(n^2), или n - 1 === O(n) // где n - количество операций за который алгоритм приходит к финальному результату причем указывается всегда наихудшая ситуация

O(n^2) - bubble sort, selection sort
O(n log n) - merge sort
O(n) - linear search
O(log n) - binary search (на отсортированном массиве)
O(1)

### Ω (omega)
Best case scenario (omega of 1 - linear search)

Ω(n^2) - bubble sort (без условия что если swap = false остановись), selection sort
Ω(n log n) - merge sort
Ω(n) - bubble sort (c условием что если swap = false, те прошли один раз по массиву и ничего не поменяли, это индикатор чтобы остановить сортировку)
Ω(log n) 
Ω(1) - linear search, binary search



## SEARCH

### linear search O(n)
O(n) (On the order of n - efficiency of the algorithm )

Причем на бесконечном пространстве O(n) === O(n/2) (когда 2 числа за 1 раз например ищем) === O(n)

В лучшем случае мы найдем за 1 операцию в худшем за n

### binary search O(log n)
Работает быстрее чем линейный поиск но подразумевается что массив **отсортирован** по порядку (хорошая аналогия такого поиска орфографический словарь, если ищу букву то открываю посередине и тд)
делением попалам
сложность поиска по отсортированному массиву быстрее чем за линейное время:
O(log n)



## SORT

### selection sort (сортировка выбором) - O(n^2)
Есть массив неупорядоченных элементов, В двойном цикле сперва берем первый айтем, затем во втором цикле сравниваем с остальными и понимаем минимальный ли он, меняем местами с 1ым элементом, затем снова пробегаемся по массиву и меняем минимальное значение уже со вторым элементом и тд

В массиве 26 элементов и проходим за 325 итерация

получается что O(1/2*n^2) отбрасываю 1/2 получаю O(n^2)

### bubble sort - O(n^2)
В двойном цикле пробегаемся по массиву и сравниваем соседние элементы, если следующий элемент меньше чем предыдущий то меняем местами, получается своего рода всплытие
сортировка пузырьком 

### Quick sort (Hoare sort) - O(log 2n^n)
Принцип разделяй и власвуй. Рекурсивной функцией делим массив на подмассивы и каждый раз рекурсивно выбираем опорный элемент, чаще всего центральный, пробегаемся по массиву и все элементы который больше добавляем в 1 массив а те которые меньше в другой массив, для каждого из полученных массивов выполняю туже операцию и так делаю до тех пор пока длинна массива не равна 1, что и будет базовым условием для выхода из рекурсии. Затем полученные массивы склеиваются в 1 большой.


### merge sort - O(n log n)
if only one item
    return
Else
   sort left half of items 
   sort right half of items 
   merge sorted halves (взять минимальный элемент из списка который был разделен с помощью мерж сорта (а мы делили на списки минимальных размеров к примеру лист из 8 элементов поделили на 8 листов с размером 1) и поставить перед большим списком и смержить)

### [Quick sort](https://stackoverflow.com/questions/234683/javascript-array-sort-implementation)
 In Chrome's v8 source code, as of today, it uses QuickSort and InsertionSort, for smaller arrays.

### recursion
это функция которая вызывает сама себя, должна иметь условие при котором вызов функции прекращается иначе будет бесконечный вызов

### Stack
Stack - like a stack of books, last in first out (lifo) (push/pop)
In other words, a stack is a list of elements that are accessible only from one end of the list, which is called the Top of Stack (ToS).

### Queue
Queue - as a real queue (push, shift) - first in first element out
В очереди элементы всегда вставляются в конец структуры, а извлекаются из ее начала (как очередь на кассу) 
FIFO - first in first out - первый вошел первый вышел
